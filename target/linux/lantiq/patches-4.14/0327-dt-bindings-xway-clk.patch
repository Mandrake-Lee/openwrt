--- /dev/null
+++ /Documentation/devicetree/bindings/clock/lantiq,mmio-mux-clock.yaml
@@ -0,0 +1,136 @@
+# SPDX-License-Identifier: GPL-2.0
+# Copyright 2020 Jorge Amorós-Argos <joramar76@gmail.com>
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/clock/lantiq,mmio-mux-clock.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Lantiq XWAY MMIO MUX Clock Device Tree Bindings
+
+maintainers:
+  - Not assigned
+
+description: |
+  This driver will decode the value contained into the register space assigned.
+  That value will be used in the table defined to connect/multiplex the output with the chosen input.
+  This driver is not exclusive to Lantiq or Lantiq XWAY as it could be universal.
+  It is exploiting the api given by clk_mux.
+
+  Multiple muxers can be declared on the same register address via device tree. See the example.
+
+
+properties:
+  "#clock-cells":
+    const: 0
+
+  compatible:
+    const:
+      - lantiq,mmio-mux-clock
+  reg:
+    maxItems: 1
+    description: Memory address where the information is stored and has to be extracted.
+
+  clocks:
+    minItems: 1
+    description: >
+      These are all the input clocks that can be multiplexed.
+ 
+  clock-output-names:
+    maxItems: 1
+  
+  big-endian: true
+    description: >
+      Usually this is mandatory as Lantiq XWAY is in all cases big endian.
+
+  lantiq,mux-mask:
+    allOf:
+      - $ref: /schemas/types.yaml#/definitions/uint32
+
+    description: >
+      The mask (width of data) of the mux value to be extracted. Hex value preferred for readability purposes.
+
+  lantiq,mux-shift:
+    allOf:
+      - $ref: /schemas/types.yaml#/definitions/uint32
+
+    description: >
+      The left bit shift for the mask declared above in order to extract the mux value
+
+  "#lantiq,mux-table-cells":
+    const: 2
+
+  lantiq,mux-table:
+    allOf:
+      - $ref: /schemas/types.yaml#/definitions/uint32
+    description: >
+      This a mapping table that connects mux value (1st column) with the input clock(2nd column). The index of the input clock depends on the order of declaration into the "clocks" property.
+
+  lantiq,mux-default-val:
+    allOf:
+      - $ref: /schemas/types.yaml#/definitions/uint32
+    description: >
+      The value declared here will be written into the space dedicated into the register (defined by mask and shift). In the end the muxer will connect the chosen input clock with the output. This is needed sometimes for muxers that are not initiated during UBoot e.g. Lantiq VR9 PCI.
+
+required:
+  - "#clock-cells"
+  - compatible
+  - reg
+  - clocks
+  - clock-output-names
+  - lantiq,mux-mask
+  - lantiq,mux-shift
+  - lantiq,mux-table
+
+examples:
+  - |
+	cgu_sys: cgu_sys@0c {
+		reg = <0x0c 4>;
+		compatible = "simple-bus";
+		big-endian;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges = <0x0 0x0c 4>;
+
+		ocp_mux: mux@0{
+			reg = <0 4>;
+			compatible = "lantiq,mmio-mux-clock";
+			big-endian;
+			#clock-cells = <0>;
+			lantiq,mux-mask = <0xF>;
+			lantiq,mux-shift = <0>;
+			clocks = <&cpu_mux>, <&cpu_div2>, <&pll0_ps3_div3>;
+			clock-output-names = "ocp_mux";
+			#lantiq,mux-table-cells = <2>;
+			lantiq,mux-table =
+			/*	val	input_clock*/
+				<0	0>,
+				<2	1>,
+				<3	2>;
+		};	//typically cpu_mux x 1/2 = 250MHz
+
+		/* This below is an example of a 2nd mux that depends on the same register*/
+		cpu_mux: mux@1{
+			reg = <0 4>;	/*Note that this value is the same as above*/
+			compatible = "lantiq,mmio-mux-clock";
+			big-endian;
+			#clock-cells = <0>;
+			lantiq,mux-mask = <0xF>;
+			lantiq,mux-shift = <4>;
+			clocks = 	<&pll0_ps3>,	<&pll0_ps1>,
+					<&pll1 0>,	<&pll0_ps2_div2>,
+					<&pll0_ps2_div4>;
+			clock-output-names = "cpu_mux";
+			#lantiq,mux-table-cells = <2>;
+			lantiq,mux-table =
+			/*	val	input_clock*/
+				<0	0>,
+				<1	1>,
+				<2	2>,
+				<3	3>,
+				<8	4>;
+		};	//typically pll0_ps1 = 500MHz
+
+		/* With this procedure, one can assign multiple muxers on the same address*/
+
+...
+    
--- /dev/null
+++ /Documentation/devicetree/bindings/clock/lantiq,pll-xway.yaml
@@ -0,0 +1,106 @@
+# SPDX-License-Identifier: GPL-2.0
+# Copyright 2020 Jorge Amorós-Argos <joramar76@gmail.com>
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/clock/lantiq,pll-xway.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Lantiq XWAY PLL Clock Device Tree Bindings
+
+maintainers:
+  - Not assigned
+
+description: |
+  This driver will decode the information contained into the register based on the PLL type.
+  Eventually, it will multiply the clock input by a fixed factor.
+  It's worth noting that this driver is read-only. It is not meant to modify the config values of the PLL as they set during U-Boot stage.
+  This driver should be applicable with AR9, AR10 & VR9. As far as we know, Lantiq Danube had another register configuration.
+
+properties:
+  "#clock-cells":
+    const: 0
+
+  compatible:
+    const:
+      - lantiq,pll-xway
+  reg:
+    maxItems: 1
+    description: Memory address where the PLL information is mainly stored
+
+  clocks:
+    maxItems: 1
+    description: >
+      This is the input of the PLL, usually a chrystal oscillator e.g. 36MHz
+ 
+  clock-output-names:
+    maxItems: 1
+  
+  big-endian: true
+    description: >
+      Usually this is mandatory as Lantiq XWAY is in all cases big endian.
+
+  lantiq,pll-type:
+    allOf:
+      - $ref: /schemas/types.yaml#/definitions/uint32
+      - enum: [0, 1, 2]
+
+    description: >
+      Physically, Lantiq PLL's are different and can be sorted as PLL0, PLL1 and PLL2.
+      Due to the construction of the SoC, only 1 type of PLL is present at the same time but all the 3 must be declared in a consistent SoC device tree.
+
+required:
+  - "#clock-cells"
+  - compatible
+  - reg
+  - clocks
+  - clock-output-names
+  - lantiq,pll-type
+
+examples:
+  - |
+ &cgu0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "lantiq,cgu-xway","simple-bus";
+		reg = <0x103000 0x1000>;
+		ranges = <0x0 0x103000 0x1000>;
+
+		pll0: pll@04 {
+			compatible = "lantiq,pll-xway";
+			reg = <0x04 4>;
+			big-endian;
+			lantiq,pll-type = <0>;
+			#clock-cells = <1>;
+			clocks = <&osc>;
+			clock-output-names = "pll0";
+
+			/*
+			 * Some information ommitted here, check vr9_cgu.dtsi
+			 * for full details
+ 			 */
+
+		};	//Set at UBOOT, typically 1000MHz, 500MHz, 666MHz and 600MHz
+
+		pll1: pll@08 {
+			compatible = "lantiq,pll-xway";
+			reg = <0x08 4>;
+			big-endian;
+			lantiq,pll-type = <1>;
+			#clock-cells = <1>;
+			clocks = <&osc>;
+			clock-output-names = 	"pll1",	"pll1_div";
+		};	//Set at UBOOT, typ. 393.219MHz
+
+		pll2: pll@60 {
+			compatible = "lantiq,pll-xway";
+			reg = <0x60 4>;
+			big-endian;
+			lantiq,pll-type = <2>;
+			#clock-cells = <1>;
+			clocks = <&osc>;
+			clock-output-names = "pll2";
+		};	// Set at UBOOT, typ. 864MHz
+    };
+
+...
+    
--- /dev/null
+++ /Documentation/devicetree/bindings/clock/lantiq,pmu-xway.yaml
@@ -0,0 +1,134 @@
+# SPDX-License-Identifier: GPL-2.0
+# Copyright 2020 Jorge Amorós-Argos <joramar76@gmail.com>
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/clock/lantiq,pmu-xway.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Lantiq XWAY PMU (gating) Clock Device Tree Bindings
+
+maintainers:
+  - Not assigned
+
+description: |
+  This driver gates/ungates the clock signal associated with the bit register dedicated to that.
+  In a broader way, the driver can handle not just one but multiple bits/gates associated with a clock.
+  Pay attention to the architecture of each SoC generation as the registers are different and therefore that should be reflected in the device tree:
+    * Danube, ASE, AR9 & VR9
+      They have 1 control enable/disable + 1 status register
+    * AR10 & GRX390
+      They have 1 control enable + 1 control disable + 1 status register
+  Note: Only first architecture is supported so far.
+
+properties:
+  "#clock-cells":
+    const: 0
+
+  compatible:
+    const:
+      - lantiq,pmu-xway
+  reg:
+    maxItems: 1
+    description: Memory address of the *status* register 
+
+  clocks:
+    maxItems: 1
+    description: >
+      This is the input of the gate
+ 
+  clock-output-names:
+    maxItems: 1
+  
+  big-endian: true
+    description: >
+      Usually this is mandatory as Lantiq XWAY is in all cases big endian.
+
+  lantiq,pmu-enable-reg:
+    allOf:
+      - $ref: /schemas/types.yaml#/definitions/uint32
+    description: >
+      Phandle to the PMU control enable register
+
+  lantiq,pmu-disable-reg:
+    allOf:
+      - $ref: /schemas/types.yaml#/definitions/uint32
+    description: >
+      Phandle to the PMU control disable register
+
+  lantiq,gate-bit-pos:
+    allOf:
+      - $ref: /schemas/types.yaml#/definitions/uint32
+
+    description: >
+      The bit position (offset) that controls the gate. Usually the value is defined in  ltq_xway_pmu.h
+      If several values are defined, then they will be stacked in order to form a mask and treated as a single gate.
+
+  lantiq,disconnect-on-boot:
+    type: boolean
+    description: >
+      This is optional. If declared with a boolean 1, the gate will be disconnected (turned off) during boot time.
+
+required:
+  - "#clock-cells"
+  - compatible
+  - reg
+  - clocks
+  - clock-output-names
+  - lantiq,pmu-enable-reg
+  - lantiq,pmu-disable-reg
+  - lantiq,gate-bit-pos
+
+examples:
+  - |
+	&pmu0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "simple-bus";
+		reg = <0x102000 0x1000>;
+		ranges = <0x0 0x102000 0x1000>;
+		big-endian;
+
+		/*This is the first power control register*/		
+		pmu_pwdcr0: pmu_pwdcr0@1c{
+			reg = <0x1c 4>;
+		};
+
+		/*This is the 1st power status register*/
+		pmu_pwdsr0: pmu_pwdsr0@20{
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "simple-bus";
+			reg = <0x20 4>;
+			ranges = <0 0x20 4>;
+
+			usb0_phy_pmu: gate@0{
+				reg = <0 4>;
+				compatible = "lantiq,pmu-xway";
+				big-endian;
+				#clock-cells = <0>;
+				clocks = <&usb_mux>;
+				clock-output-names = "usb0_phy";
+				//For VR9, both enable & disable control regs are the same
+				lantiq,pmu-enable-reg = <&pmu_pwdcr0>;
+				lantiq,pmu-disable-reg = <&pmu_pwdcr0>;
+				lantiq,gate-bit-pos = <PMU_USB0_P>;
+				lantiq,disconnect-on-boot = <1>;
+			};
+
+			/* Here's a example of how to add a 2nd gate to the same register*/
+			pci_pmu: gate@4{
+				reg = <0 4>;	/*Pay attention to this address, same as above*/
+				compatible = "lantiq,pmu-xway";
+				big-endian;
+				#clock-cells = <0>;
+				clocks = <&pci_mux>;
+				clock-output-names = "pci_pmu";
+				lantiq,pmu-enable-reg = <&pmu_pwdcr0>;
+				lantiq,pmu-disable-reg = <&pmu_pwdcr0>;
+				lantiq,gate-bit-pos = <PMU_PCI>;
+				lantiq,disconnect-on-boot = <1>;
+			};
+
+			/* And we could add more gates */
+...
+    
