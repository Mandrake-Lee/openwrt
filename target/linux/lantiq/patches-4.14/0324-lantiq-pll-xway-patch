
--- /dev/null
+++ /drivers/clk/lantiq/clk-xway-pll.c
@@ -0,0 +1,527 @@
+// SPDX-License-Identifier: GPL-2.0
+
+/*
+ *  clk-xway-pll.c
+ *  OF driver for PLL's of Lantiq XWAY family
+ *  i.e. VR9, AR9, AR10 (others WIP)
+ *
+ *  Copyright (C) 2020 Jorge Amor√≥s-Argos <jamoros76@gmail.com>
+ *
+ *  Based on GNU sources:
+ *
+ *  ifxmips_vr9_clk.c by several authors
+ *  Copyright (C) 2005 to 2009, Infineon Technologies
+ *
+ *  xway-pll.c
+ *  Copyright (C) 2010 John Crispin <blogic@openwrt.org>
+ */
+
+/*
+ * VERSION HISTORY
+ * 01	May 2020	First release
+ */
+
+
+/*
+ * FOREWORD
+ * For the curious minds, mainly all the registers, its fields, meanings
+ * and also the formulae that yield into a frequency rate can be found in
+ * "ifxmips_vr9_clk.c"
+ * The present file is a condensed approach after studying those sources and adapting
+ * the result to the Common Clock Framework.
+ * Unfortunately, not everything is understood as Lantiq hasn't released the datasheets
+ * This driver has some limitations that shouldn't be an issue under standard
+ * conditions:
+ *	- Because the construction of the hardware, all 3 PLLs must be properly
+ *	  declared into the device tree. This is needed especially for PLL1 that
+ *	  has some values stored in PLL0 and PLL2
+ *	- All the possible output clocks are created, no matter if they are ENABLE or not
+ * 	- The clocks are modeled as fixed-ratio of the parent clock, typ. a xtal
+ *	- This has some round-up limitations as fixed-ratio are 16bits fractional
+ *	- Also frequencies are not meant to be updated after boot as they remain static blocks
+ *	  CPU frequency change can be achieved via mux of different clocks
+ *	  for instance
+ *	- This makes sense because the PLL values are set during UBOOT phase to match
+ *	  the hardware on the board and never to be modified afterwards
+ */
+
+/*
+ * TODO: Transform this driver to a #clock-cells = 0, i.e. one-input one-output
+ * The only roadblock is pll1_div; use standard clock_divider api
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+
+#define GET_BITS(x, msb, lsb) \
+	(((x) & ((1 << ((msb) + 1)) - 1)) >> (lsb))
+
+typedef enum {CFG_PLLM, CFG_PLLN, CFG_PLLK, CFG_FRAC, CFG_DSMSEL,
+		SRC, BYPASS, PHASE_DIVIDER, CFG_INPUT_DIV, CFG_CTEN,
+		ENABLE, LOCKED, PLL1_FMOD_S, PS1_EN, PS2_EN,
+		CFG_PLLD, PLL1_K_LO } cgu_pll_tags;
+
+typedef enum {LTQ_XWAY_PLL0, LTQ_XWAY_PLL1, LTQ_XWAY_PLL2} ltq_xway_plls;
+
+/*
+ * s32 pll_check_tag
+ * Description:
+ * Routine to extract all the different fields contained into a PLL register
+ * There's been identified 3 kinds of Lantiq PLL's, named 0, 1 and 2
+ * They are not physically the same and they don't serve to the same purpose
+ * Inputs:
+ * u32		regval		Value of the PLL register. Beware endianness.
+ * cgu_pll_tags	tag		Enum type that defines what we want to extract
+ * int		pll_type	Type 0, 1 or 2
+ * Returns:
+ * -1	Error
+ * val	The extracted value
+ */
+
+s32 pll_check_tag(u32 regval, cgu_pll_tags tag, int pll_type){
+	if (pll_type == 0){
+		switch (tag){
+			case ENABLE:
+				return (regval & BIT(0)) >> 0;
+			case LOCKED:
+				return (regval & BIT(1)) >> 1;
+			case CFG_PLLM:
+				return GET_BITS(regval, 5, 2);
+			case CFG_PLLN:
+				return GET_BITS(regval, 13, 6);
+			case PS1_EN:
+				return (regval & BIT(20)) >> 20;
+			case PS2_EN:
+				return (regval & BIT(21)) >> 21;
+			case PLL1_FMOD_S:
+				return GET_BITS(regval, 23, 22);
+			case BYPASS:
+				return (regval & BIT(30)) >> 30;
+			default:
+				return -1;
+		}
+	}else if (pll_type == 1){
+		switch (tag){
+			case ENABLE:
+				return (regval & BIT(0)) >> 0;
+			case LOCKED:
+				return (regval & BIT(1)) >> 1;
+			case CFG_PLLM:
+				return GET_BITS(regval, 5, 2);
+			case CFG_PLLN:
+				return GET_BITS(regval, 12, 6);
+			case CFG_PLLD:
+				return GET_BITS(regval, 16, 13);
+			case CFG_PLLK:
+				return GET_BITS(regval, 26, 17);
+			case CFG_FRAC:
+				return (regval & BIT(27)) >> 27;
+			case CFG_DSMSEL:
+				return (regval & BIT(28)) >> 28;
+			case CFG_CTEN:
+				return (regval & BIT(29)) >> 29;
+			case BYPASS:
+				return (regval & BIT(30)) >> 30;
+			case PHASE_DIVIDER:
+				return (regval & BIT(31)) >> 31;
+		}	
+	}else if (pll_type == 2){
+		switch (tag){
+			case ENABLE:
+				return (regval & BIT(0)) >> 0;
+			case LOCKED:
+				return (regval & BIT(1)) >> 1;
+			case CFG_PLLM:
+				return GET_BITS(regval, 5, 2);
+			case CFG_PLLN:
+				return GET_BITS(regval, 13, 6);
+			case PLL1_K_LO:
+				return GET_BITS(regval, 29, 20);
+			case BYPASS:
+				return (regval & BIT(30)) >> 30;
+			default:
+				return -1;
+		}
+	}
+}
+
+/*
+ * u32 ltq_pll_readl
+ * Description:
+ * Reads the value stored in a memory register taking into account endianness
+ * Inputs:
+ * device_node	*node	The current DT node
+ */
+u32 ltq_pll_readl(struct device_node *node){
+	void __iomem *base;
+	base = of_iomap(node, 0);
+
+	if (!base){
+		pr_err("%pOFn: failed to map address\n", node);
+		return ERR_PTR(-EIO);
+	}	
+
+	iounmap(base);
+	
+	if (of_device_is_big_endian(node))
+		return ioread32be(base);
+	else
+		return readl(base);
+}
+
+
+/*  s32 of_ltq_xway_find_pll1_K_lo
+ *  Description:
+ *  This function will search the device tree for the node that contains
+ *  PLL2 (type 2) and extract the value in the register for PLL1_K_LO
+ *  This is needed for PLL1 in fractional mode
+ *  Return -1 if no PLL0 is found (bad device tree definition)
+ */
+
+s32 of_ltq_xway_find_pll1_K_lo(void){
+	struct device_node *node = NULL;
+	u32 regval, pll_type, K_lo;
+	int i;
+	do{
+		node = of_find_node_with_property (node, "lantiq,pll-type");
+		of_property_read_u32(node,"lantiq,pll-type", &pll_type);
+	}while( pll_type!= 2 || node == NULL);
+
+	if (node){
+		regval = ltq_pll_readl(node);
+		K_lo =pll_check_tag(regval,PLL1_K_LO,2);
+
+		return (s32) K_lo;
+	}
+
+	return -1;
+}
+
+
+/*  int of_ltq_xway_find_pll0_fmod_s
+ *  Description:
+ *  This function will search the device tree for the node that contains
+ *  PLL0 (type 0) and extract the value in the register for fmod_s
+ *  This is needed for PLL1 in fractional mode
+ *  Return -1 if no PLL0 is found (bad device tree definition)
+ */
+
+int of_ltq_xway_find_pll0_fmod_s(void){
+	struct device_node *node = NULL;
+	u32 regval, pll_type, fmod_s;
+	int i;
+	do{
+		node = of_find_node_with_property (node, "lantiq,pll-type");
+		of_property_read_u32(node,"lantiq,pll-type", &pll_type);
+	}while( pll_type!= 0 || node == NULL);
+
+	if (node){
+		regval = ltq_pll_readl(node);
+		fmod_s =pll_check_tag(regval,PLL1_FMOD_S,0);
+		return (int) fmod_s;
+	}
+
+	return -1;
+}
+
+/*
+ * int cgu_pll1_get_num_div
+ * Description:
+ * For PLL1, return the best accurate 16bits couple num/div intended for fixed-factor clock
+ * Inputs:
+ * u32 regval	:Valueof PLL1 register
+ * u16 *num	:Where num value will be stored
+ * u16 *div	:Where div value will be stored
+ * Return 0 on success
+ */
+int cgu_pll1_get_num_div(u32 regval, u16 *num, u16 *div){
+	u32 auxnum , auxdiv;
+	u32 K_lo, fmod_s;
+
+	if (!pll_check_tag(regval,CFG_FRAC,1) && !pll_check_tag(regval,CFG_DSMSEL,1)){
+		/* Original formula called mash_dsm */
+		auxnum = (pll_check_tag(regval,CFG_PLLN,1)+1)<<10 + pll_check_tag(regval,CFG_PLLK,1);
+		auxdiv = (pll_check_tag(regval,CFG_PLLM,1)+1)<<10;
+	}
+	else if (!pll_check_tag(regval,PHASE_DIVIDER,1)){
+		/* Original formula called ssff_dsm_1 */
+		auxnum = (pll_check_tag(regval,CFG_PLLN,1)+1)<<11 + pll_check_tag(regval,CFG_PLLK,1)+512;
+		auxdiv = (pll_check_tag(regval,CFG_PLLM,1)+1)<<11;
+	}
+	else {
+		/* Original formula called ssff_dsm_2 */
+
+		/* WARNING: Due to the absence of datasheet and because the code is not clear with
+		 * the formula (the so called offsets are jumping between SoC families), the below
+		 * equation has to be taken as an educated guess.
+		 * With the only value that we have from the code of VR9 osc= 36MHz, PLL1 = 393.219MHz
+		 * The equation below will result in 393.149MHz (before rounding to 16bits)
+		 */
+	
+		fmod_s = of_ltq_xway_find_pll0_fmod_s();
+		K_lo = of_ltq_xway_find_pll1_K_lo();
+		auxnum = (pll_check_tag(regval,CFG_PLLN,1)+1)<<12;
+		auxnum += pll_check_tag(regval,CFG_PLLK,1) + K_lo + fmod_s*512;
+		auxdiv = (pll_check_tag(regval,CFG_PLLM,1)+1)<<12;
+	}
+
+	/* Now squeeze the data to fit 16 bits because the fixed-factor clock
+	 * works with this constraint
+	 */ 
+	while ((auxnum & ~0xffff) || (auxdiv & ~0xffff)){
+		auxnum = auxnum >>1;
+		auxdiv = auxdiv >>1;
+	}
+
+	*num = (u16) auxnum;
+	*div = (u16) auxdiv;
+	
+	return 0;
+}
+
+
+/*
+ * int ltq_xway_pll_generate_clk_hw
+ * Description:
+ * This funtion will generate, based on the pll register content and the pll type,
+ * the corresponding output clocks:
+ * 	For PLL0, there will be 4, being the so named PLL0_psx (Phased Shifter), dividers of
+ * 	the root one.
+ *	For PLL1, there will be 2, the root and the one affected by the programmable divider
+ *	For PLL2, there will be only the root
+ * Inputs:
+ * device_node	*node		The current DT node
+ * clk_hw	**hws		Array of clk_hw where all the clks will be allocated
+ * u32		freq_in		The frequency (Hz) of the input clk, usually a xtal osc
+ * ltq_xway_plls pll_type	Enum pll type
+ * char		*parent_name	Name of the input clk, the one of freq_in
+ */
+int ltq_xway_pll_generate_clk_hw(struct device_node *node, struct clk_hw **hws,
+				  u32 freq_in, ltq_xway_plls pll_type,
+				 char *parent_name)
+{
+	const char *pll_name, *clk_name;
+	u32 regval;
+	u32 freq_out, div_pll1;
+	u32 M, N, isbypass;
+	static const u32 flags = CLK_SET_RATE_PARENT;
+	int i;
+	u16 num, div;
+	u64 pll1_factor;
+
+	/* Get register value */
+	regval = ltq_pll_readl(node);
+
+	/* Extract relevant information */
+	M = pll_check_tag(regval, CFG_PLLM, pll_type);
+	N = pll_check_tag(regval, CFG_PLLN, pll_type);
+	isbypass = pll_check_tag(regval, BYPASS, pll_type);
+
+	of_property_read_string_index(node, "clock-output-names", 0, &pll_name);
+
+	/*Now we customize the rest of the clocks depending on the PLL type*/
+	switch (pll_type){
+		case LTQ_XWAY_PLL0:
+			/* Root PLL0 */
+			if (!isbypass)
+				hws[0] = clk_hw_register_fixed_factor(NULL, pll_name, parent_name,0,
+						2*(N+1), (M+1));
+			else
+				hws[0] = clk_hw_register_fixed_factor(NULL, pll_name, parent_name,0,
+						1, 1);
+			/*
+			 * The PLL0_psx derivatives are fixed-factor (dividers) that should be
+			 * declared in the device tree as a standard fixed-factor clock.
+			 * We know that ps1 and ps2 have a enable/disable bit in the register,
+			 * however this feature is not implemented in this driver
+			 */
+
+			break;
+
+		case LTQ_XWAY_PLL1:
+			cgu_pll1_get_num_div(regval, &num, &div);
+			/* Root PLL1*/
+			if (!isbypass)
+				hws[0] = clk_hw_register_fixed_factor(NULL, pll_name,
+							 parent_name,flags, num, div);
+			else
+				hws[0] = clk_hw_register_fixed_factor(NULL, pll_name,
+							 parent_name,flags, 1, 1);
+		
+			of_property_read_string_index(node, "clock-output-names", 1, &clk_name);
+
+			/*PLL1_ps1 is a pure divider base on value of CFG_PLLD*/
+			/* TODO: Move this clock out into the device tree as a clock_divider*/
+
+			div_pll1 = pll_check_tag(regval, CFG_PLLD, pll_type);
+			hws[1] = clk_hw_register_fixed_factor(NULL, clk_name, pll_name,flags,
+						1, div_pll1);
+			break;
+
+		case LTQ_XWAY_PLL2:
+			/* Root PLL1*/
+			if (!isbypass)
+				hws[0] = clk_hw_register_fixed_factor(NULL, pll_name,
+							parent_name,flags,
+							2*(N+1), (M+1));
+			else
+				hws[0] = clk_hw_register_fixed_factor(NULL, pll_name,
+							parent_name,flags,
+							1, 1);
+			break;
+		default:
+			freq_out = -1;
+		}
+}
+
+
+static void *ltq_xway_pll_clk_setup(struct device_node *node){
+	struct of_phandle_args clkspec;
+	struct clk_hw_onecell_data *clk_data;
+	struct clk *clk;
+	struct clk_hw **hws;
+	const char *clk_name, *parent_name;
+	u32 regval;
+	u32 freq_in;
+	int i, ret;
+	ltq_xway_plls pll_type;
+	static const u32 num_clkout[3]={1,2,1};
+	int fmod_s;
+
+	/* Get register value */
+	regval = ltq_pll_readl(node);
+	
+	/* Get parent oscillator data*/
+	ret = of_parse_phandle_with_args(node, "clocks", "#clock-cells", 0,
+					&clkspec);
+	if (ret<0){
+		pr_err("%pOFn: No phandle available for parent clock!", node);
+		return -1;
+	}
+	
+	clk = of_clk_get_from_provider(&clkspec);
+
+	freq_in = clk_get_rate(clk);
+	parent_name = of_clk_get_parent_name(node, 0);
+
+	/* Get pll type */ 
+	ret = of_property_read_u32(node,"lantiq,pll-type", &pll_type);
+	if (ret<0){
+		pr_info("%pOFn: Property lantiq,pll-type not defined!", node);
+		pll_type = 0;
+	}
+
+	/* Sanity check of the clock output names*/
+	ret = of_property_count_strings(node, "clock-output-names");
+	if (ret<0)
+		pr_info("%pOFn: No clock-output-names defined", node);
+
+	of_property_read_string_index(node, "clock-output-names", 0, &clk_name);
+	
+	if (pll_type == LTQ_XWAY_PLL1 && pll_check_tag(regval, CFG_FRAC, pll_type))
+	{
+		fmod_s = of_ltq_xway_find_pll0_fmod_s();
+
+		if (fmod_s<0)
+			pr_warning("%pOFn:Couldn't find PLL0 in device tree, node");
+	}
+
+	/*Reserve memory for the hw based on the pll type*/
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 18, 0))
+	clk_data =kzalloc( struct_size(clk_data, hws, num_clkout[pll_type]),
+			GFP_KERNEL);
+#else
+	clk_data = kzalloc(	sizeof(*clk_data)+
+				sizeof(*clk_data->hws)*num_clkout[pll_type],
+				GFP_KERNEL);
+#endif
+	clk_data->num = num_clkout[pll_type];
+	hws = clk_data->hws;
+
+	ltq_xway_pll_generate_clk_hw( node, clk_data->hws, freq_in, pll_type,
+				 parent_name);
+
+	/* Checking the registering of the clk hws*/
+	for (i=0;i<clk_data->num;i++){
+		if (IS_ERR(hws[i])) {
+			pr_err("%pOFn: failed to register lantiq, pll as fixed rate clock\n", node);
+			return hws[i];
+		}
+	}
+
+	ret = of_clk_add_hw_provider(node, of_clk_hw_onecell_get, 
+						clk_data);
+
+	if (ret) {
+		pr_err("%pOFn: failed to add clock provider\n", node);
+	}	
+
+	return 0;
+}
+
+
+/**
+ * This is not executed when of_xway_pll_clk_setup succeeded.
+ */
+static int of_ltq_xway_pll_clk_probe(struct platform_device *pdev)
+{
+	struct clk_hw *clk;
+
+	clk = ltq_xway_pll_clk_setup(pdev->dev.of_node);
+	if (IS_ERR(clk))
+		return PTR_ERR(clk);
+
+	platform_set_drvdata(pdev, clk);
+
+	return 0;
+}
+
+static void __init of_ltq_xway_pll_clk_setup(struct device_node *node)
+{
+	ltq_xway_pll_clk_setup(node);
+}
+
+static int of_ltq_xway_pmu_clk_remove(struct platform_device *pdev)
+{
+	struct clk_hw **hws = platform_get_drvdata(pdev);
+	int i, length = sizeof(hws)/sizeof(hws[0]);
+
+	of_clk_del_provider(pdev->dev.of_node);
+
+	for (i=0;i<length;i++)
+		clk_hw_unregister_fixed_rate(hws[i]);
+
+	return 0;
+}
+
+CLK_OF_DECLARE(xway_pll_clk, "lantiq,pll-xway", of_ltq_xway_pll_clk_setup);
+
+static const struct of_device_id of_ltq_xway_pll_clk_ids[] = {
+	{ .compatible = "lantiq,pll-xway" },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(of, of_ltq_xway_pll_clk_ids);
+
+static struct platform_driver of_ltq_xway_pll_clk_driver = {
+	.driver = {
+		.name = "of_lantiq_xway_pll_clk",
+		.of_match_table = of_ltq_xway_pll_clk_ids,
+	},
+	.probe = 	of_ltq_xway_pll_clk_probe,
+	.remove =	of_ltq_xway_pmu_clk_remove,
+};
+module_platform_driver(of_ltq_xway_pll_clk_driver);
+
+MODULE_AUTHOR("Jorge Amor√≥s-Argos <jamoros76@gmail.com>");
+MODULE_DESCRIPTION("Lantiq xway PMU clock driver");
+MODULE_LICENSE("GPL v2");
+
